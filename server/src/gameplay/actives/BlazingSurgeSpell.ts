import { BaseSpell, ISpellConfig } from "../base/BaseSpell";
import { IBattleParticipant, IBattleAction } from "../../models/Battle";
import { EffectManager } from "../EffectManager";

class BlazingSurgeSpell extends BaseSpell {
  constructor() {
    const config: ISpellConfig = {
      id: "blazing_surge",
      name: "Blazing Surge",
      description:
        "Inflige des d√©g√¢ts magiques de zone et applique Br√ªlure. Si la cible br√ªle d√©j√†, les d√©g√¢ts sont augment√©s de 25%.",
      type: "active",
      category: "damage",
      targetType: "all_enemies",

      energyCost: 45,
      baseCooldown: 3,

      maxLevel: 10,
      scalingType: "linear",

      element: "Fire",
      requiresRole: ["DPS Ranged", "Mage"],

      animationType: "explosion_fire",
      soundEffect: "blazing_surge_cast",
    };

    super(config);
  }

  execute(
    caster: IBattleParticipant,
    targets: IBattleParticipant[],
    spellLevel: number,
    battleContext?: any
  ): IBattleAction {
    const turn = battleContext?.currentTurn || 1;
    const action = this.createBaseAction(caster, targets, "skill", turn);

    const baseDamage = this.getBaseDamage(spellLevel);

    action.damage = 0;
    action.energyCost = this.getEnergyCost(spellLevel);
    action.energyGain = 8; // AoE -> plus de r√©cup√©ration d'√©nergie
    action.debuffsApplied = [];
    action.perTargetDamage = {}; // ‚úÖ nouveau champ utile pour stocker d√©g√¢ts par cible

    for (const target of targets) {
      if (!target.status.alive) continue;

      // Calcul des d√©g√¢ts individuels
      let damage = this.calculateDamage(caster, target, baseDamage, spellLevel, "magical");

      // Bonus si la cible est d√©j√† br√ªl√©e
      if (target.status.debuffs.includes("burn")) {
        damage = Math.floor(damage * 1.25);
      }

      // Stocker les d√©g√¢ts dans l‚Äôaction
      action.perTargetDamage[target.heroId] = damage;
      action.damage += damage;

      // Application de la br√ªlure
      const burnDuration = this.getBurnDuration(spellLevel);
      const burnStacks = 1;

      const burnResult = EffectManager.applyEffect("burn", target, caster, burnDuration, burnStacks);
      if (burnResult && burnResult.message) {
        console.log(`üî• ${burnResult.message}`);
      }

      action.debuffsApplied.push("burn");
    }

    return action;
  }

  // ----- D√©tails de calcul -----

  private getBaseDamage(spellLevel: number): number {
    // D√©g√¢ts mod√©r√©s AoE : niveau 1: 90 ‚Üí niveau 10: 200
    return Math.floor(90 + (spellLevel - 1) * 12);
  }

  private getBurnDuration(spellLevel: number): number {
    // Fixe √† 2 tours selon la description
    return 2;
  }

  protected additionalCanCastChecks(caster: IBattleParticipant, spellLevel: number): boolean {
    // Ne peut pas √™tre lanc√© sous silence
    return !caster.status.debuffs.includes("silence");
  }
}

export const blazingSurgeSpell = new BlazingSurgeSpell();
export { BlazingSurgeSpell };

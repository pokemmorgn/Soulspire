#!/usr/bin/env ts-node

// server/src/scripts/testForge.ts
// Script de test complet du syst√®me de forge
// Usage: npx ts-node src/scripts/testForge.ts

import mongoose from "mongoose";
import dotenv from "dotenv";
import Player from "../models/Player";
import Hero from "../models/Hero";
import Inventory from "../models/Inventory";
import { ForgeConfig } from "../models/forging/ForgeConfig";
import { ForgeOperation } from "../models/forging/ForgeOperation";
import { ForgeStats } from "../models/forging/ForgeStats";
import { ForgeService } from "../services/forge/ForgeService";
import EnhancementService from "../services/forge/EnhancementService";
import ReforgeService from "../services/forge/ReforgeService";
import FusionService from "../services/forge/FusionService";
import TierUpgradeService from "../services/forge/TierUpgradeService";

dotenv.config();

const MONGO_URI = process.env.MONGO_URI || "mongodb://localhost:27017/unity-gacha-game";

// Couleurs pour l'affichage console
const colors = {
  reset: "\x1b[0m",
  bright: "\x1b[1m",
  red: "\x1b[31m",
  green: "\x1b[32m",
  yellow: "\x1b[33m",
  blue: "\x1b[34m",
  magenta: "\x1b[35m",
  cyan: "\x1b[36m"
};

function colorLog(color: string, message: string) {
  console.log(`${color}${message}${colors.reset}`);
}

class ForgeTester {
  private testPlayerId: string = "";
  private serverId: string = "S1";
  private testItems: any[] = [];

  // === FONCTION PRINCIPALE ===
  public async runAllTests(): Promise<void> {
    try {
      colorLog(colors.cyan, "\nüî® === TEST COMPLET DU SYST√àME DE FORGE ===\n");
      
      await this.setupDatabase();
      await this.setupTestPlayer();
      await this.setupTestItems();
      
      // Tests principaux
      await this.testForgeConfiguration();
      await this.testEnhancementModule();
      await this.testReforgeModule();
      await this.testFusionModule();
      await this.testTierUpgradeModule();
      await this.testForgeServiceIntegration();
      await this.testBatchOperations();
      await this.testRecommendations();
      await this.testAnalytics();
      await this.testPerformance();
      
      await this.displayFinalStats();
      
      colorLog(colors.green, "\nüéâ === TOUS LES TESTS DE FORGE TERMIN√âS AVEC SUCC√àS ===\n");
      
    } catch (error) {
      colorLog(colors.red, `‚ùå Erreur lors des tests: ${error}`);
      console.error(error);
      throw error;
    }
  }

  // === SETUP ET INITIALISATION ===
  
  public async setupDatabase(): Promise<void> {
    await mongoose.connect(MONGO_URI);
    colorLog(colors.green, "‚úÖ Connect√© √† MongoDB");
    
    // Nettoyer les donn√©es de test pr√©c√©dentes
    await this.cleanupTestData();
    
    // V√©rifier/cr√©er configuration forge
    await this.ensureForgeConfig();
  }

  private async cleanupTestData(): Promise<void> {
    await Player.deleteMany({ username: { $regex: /^ForgeTest/ } });
    await ForgeOperation.deleteMany({ playerId: { $regex: /^test/ } });
    await ForgeStats.deleteMany({ playerId: { $regex: /^test/ } });
    await Inventory.deleteMany({ playerId: { $regex: /^test/ } });
    
    colorLog(colors.yellow, "üßπ Donn√©es de test pr√©c√©dentes nettoy√©es");
  }

  private async ensureForgeConfig(): Promise<void> {
    let config = await ForgeConfig.findOne({ isActive: true });
    
    if (!config) {
      colorLog(colors.yellow, "‚öôÔ∏è Cr√©ation de la configuration forge par d√©faut...");
      config = await (ForgeConfig as any).createDefaultConfig();
    }
    
    colorLog(colors.blue, `üîß Configuration forge active: ${config.configName} v${config.version}`);
  }

  public async setupTestPlayer(): Promise<void> {
    const testPlayer = new Player({
      username: "ForgeTestPlayer",
      password: "test123",
      serverId: this.serverId,
      gold: 100000,
      gems: 10000,
      paidGems: 1000,
      world: 5,
      level: 50
    });
    
    await testPlayer.save();
    this.testPlayerId = (testPlayer._id as any).toString();
    
    colorLog(colors.green, `üë§ Joueur de test cr√©√©: ${testPlayer.displayName} (ID: ${this.testPlayerId})`);
  }

  private async setupTestItems(): Promise<void> {
    // Cr√©er un inventaire de test avec diff√©rents types d'√©quipements
    const inventory = new Inventory({
      playerId: this.testPlayerId,
      storage: {
        weapons: [],
        armors: [],
        helmets: [],
        boots: [],
        gloves: [],
        accessories: [],
        materials: []
      }
    });

    // G√©n√©rer des items de test avec diff√©rentes raret√©s et niveaux
    const itemTemplates = [
      { category: 'weapons', name: 'Test Sword', rarity: 'Epic', slot: 'Weapon' },
      { category: 'armors', name: 'Test Armor', rarity: 'Legendary', slot: 'Armor' },
      { category: 'helmets', name: 'Test Helmet', rarity: 'Rare', slot: 'Helmet' },
      { category: 'boots', name: 'Test Boots', rarity: 'Common', slot: 'Boots' },
      { category: 'gloves', name: 'Test Gloves', rarity: 'Mythic', slot: 'Gloves' },
      { category: 'accessories', name: 'Test Ring', rarity: 'Epic', slot: 'Accessory' }
    ];

    for (let i = 0; i < itemTemplates.length; i++) {
      const template = itemTemplates[i];
      
      // Cr√©er plusieurs exemplaires pour tester la fusion
      for (let j = 0; j < 5; j++) {
        const item = this.createTestItem(template, i * 5 + j);
        inventory.storage[template.category as keyof typeof inventory.storage].push(item);
        this.testItems.push(item);
      }
    }

    // Ajouter des mat√©riaux de test
    const materials = [
      'enhancement_stone', 'reforge_stone', 'fusion_stone', 'tier_stone',
      'magic_crystal', 'dragon_scale', 'phoenix_feather', 'celestial_essence',
      'silver_dust', 'gold_dust', 'platinum_dust', 'mythic_dust'
    ];

    for (const material of materials) {
      inventory.storage.materials.push({
        instanceId: this.generateId(),
        itemId: material,
        quantity: 100,
        acquiredDate: new Date()
      });
    }

    await inventory.save();
    
    colorLog(colors.blue, `‚öîÔ∏è ${this.testItems.length} items de test cr√©√©s dans l'inventaire`);
    colorLog(colors.blue, `üì¶ ${materials.length} types de mat√©riaux ajout√©s`);
  }

  private createTestItem(template: any, index: number): any {
    return {
      instanceId: this.generateId(),
      itemId: `test_${template.category}_${index}`,
      quantity: 1,
      level: Math.floor(Math.random() * 30) + 1,
      enhancement: Math.floor(Math.random() * 10),
      tier: Math.floor(Math.random() * 3) + 1,
      stats: this.generateRandomStats(template.slot),
      baseStats: this.generateRandomStats(template.slot),
      statsPerLevel: this.generateRandomStatsPerLevel(template.slot),
      rarity: template.rarity,
      equipmentSlot: template.slot,
      category: 'Equipment',
      name: `${template.name} +${Math.floor(Math.random() * 10)}`,
      isEquipped: false,
      acquiredDate: new Date(),
      equipmentData: {
        durability: 100,
        socketedGems: [],
        upgradeHistory: []
      }
    };
  }

  private generateRandomStats(slot: string): { [stat: string]: number } {
    const slotStats: { [slot: string]: string[] } = {
      'Weapon': ['atk', 'crit', 'critDamage', 'accuracy'],
      'Armor': ['hp', 'def', 'critResist', 'dodge'],
      'Helmet': ['hp', 'def', 'moral', 'energyRegen'],
      'Boots': ['hp', 'vitesse', 'dodge', 'energyRegen'],
      'Gloves': ['atk', 'crit', 'accuracy', 'critDamage'],
      'Accessory': ['hp', 'atk', 'crit', 'healingBonus']
    };

    const availableStats = slotStats[slot] || ['hp', 'atk'];
    const stats: { [stat: string]: number } = {};
    
    // G√©n√©rer 2-4 stats au hasard
    const statCount = Math.floor(Math.random() * 3) + 2;
    const selectedStats = availableStats.slice(0, statCount);
    
    for (const stat of selectedStats) {
      stats[stat] = Math.floor(Math.random() * 100) + 50;
    }
    
    return stats;
  }

  private generateRandomStatsPerLevel(slot: string): { [stat: string]: number } {
    const stats = this.generateRandomStats(slot);
    const statsPerLevel: { [stat: string]: number } = {};
    
    for (const stat of Object.keys(stats)) {
      statsPerLevel[stat] = Math.floor(Math.random() * 10) + 5;
    }
    
    return statsPerLevel;
  }

  private generateId(): string {
    return 'test_' + Math.random().toString(36).substring(2, 15);
  }

  // === TESTS DU SYST√àME ===

  private async testForgeConfiguration(): Promise<void> {
    colorLog(colors.cyan, "\n‚öôÔ∏è === TEST CONFIGURATION FORGE ===");
    
    const config = await ForgeConfig.findOne({ isActive: true });
    
    if (!config) {
      throw new Error("Aucune configuration forge active trouv√©e");
    }

    console.log(`üìã Configuration: ${config.configName} v${config.version}`);
    console.log(`üóìÔ∏è Appliqu√©e le: ${config.appliedDate.toISOString().split('T')[0]}`);
    
    // Tester les modules
    const modules = ['reforge', 'enhancement', 'fusion', 'tierUpgrade'];
    for (const module of modules) {
      const enabled = config.isModuleEnabled(module);
      const status = enabled ? `${colors.green}ACTIV√â${colors.reset}` : `${colors.red}D√âSACTIV√â${colors.reset}`;
      console.log(`   üîß ${module}: ${status}`);
    }

    // Tester la configuration effective avec √©v√©nements
    const enhancementConfig = config.getEffectiveConfig('enhancement');
    if (enhancementConfig) {
      console.log(`   üí∞ Co√ªt enhancement de base: ${enhancementConfig.baseGoldCost} or`);
      console.log(`   üíé Co√ªt enhancement de base: ${enhancementConfig.baseGemCost} gemmes`);
      console.log(`   üìä Niveau max enhancement: ${enhancementConfig.maxLevel}`);
    }

    colorLog(colors.green, "‚úÖ Test configuration termin√©");
  }

  private async testEnhancementModule(): Promise<void> {
    colorLog(colors.cyan, "\n‚ö° === TEST MODULE ENHANCEMENT ===");
    
    const enhancementService = new EnhancementService(this.testPlayerId);
    
    // Test 1: R√©cup√©rer items enhanceables
    console.log("\nüìù Test r√©cup√©ration items enhanceables:");
    const enhanceableItems = await enhancementService.getEnhanceableItems();
    console.log(`   üéØ ${enhanceableItems.length} items enhanceables trouv√©s`);
    
    if (enhanceableItems.length === 0) {
      console.log("   ‚ö†Ô∏è Aucun item enhanceable, cr√©ation d'un item de test...");
      return;
    }

    // Test 2: Calculer co√ªt enhancement
    const testItem = enhanceableItems[0];
    console.log(`\nüí∞ Test calcul co√ªt enhancement pour: ${testItem.name}`);
    try {
      const cost = await enhancementService.getEnhancementCost(testItem.instanceId);
      console.log(`   üí∞ Co√ªt: ${cost.gold} or, ${cost.gems} gemmes`);
      if (cost.materials) {
        console.log(`   üì¶ Mat√©riaux: ${Object.entries(cost.materials).map(([id, qty]) => `${id}:${qty}`).join(', ')}`);
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur calcul co√ªt: ${error.message}`);
    }

    // Test 3: Tentative enhancement
    console.log(`\n‚ö° Test enhancement de: ${testItem.name} (+${testItem.enhancement})`);
    try {
      const result = await enhancementService.attemptEnhancement(testItem.instanceId);
      
      if (result.success) {
        console.log(`   ‚úÖ Enhancement r√©ussi: +${result.previousLevel} ‚Üí +${result.newLevel}`);
        console.log(`   üìà Gain de puissance: ${result.statsImprovement.powerIncrease}`);
        console.log(`   üéØ Pity actuel: ${result.pityInfo.currentPity}`);
      } else {
        console.log(`   ‚ùå Enhancement √©chou√©: ${result.message}`);
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur enhancement: ${error.message}`);
    }

    // Test 4: Enhancement avec garantie
    console.log(`\nüíé Test enhancement avec garantie:`);
    try {
      const guaranteedResult = await enhancementService.attemptEnhancement(testItem.instanceId, {
        usePaidGemsToGuarantee: true
      });
      
      if (guaranteedResult.success) {
        console.log(`   ‚úÖ Enhancement garanti r√©ussi: +${guaranteedResult.previousLevel} ‚Üí +${guaranteedResult.newLevel}`);
      }
    } catch (error: any) {
      console.log(`   ‚ö†Ô∏è Enhancement garanti non disponible: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test module enhancement termin√©");
  }

  private async testReforgeModule(): Promise<void> {
    colorLog(colors.cyan, "\nüîÑ === TEST MODULE REFORGE ===");
    
    const reforgeService = new ReforgeService(this.testPlayerId);
    
    // Test 1: R√©cup√©rer items reforgeables
    console.log("\nüìù Test r√©cup√©ration items reforgeables:");
    const reforgeableItems = await reforgeService.getReforgeableItems();
    console.log(`   üéØ ${reforgeableItems.length} items reforgeables trouv√©s`);
    
    if (reforgeableItems.length === 0) {
      console.log("   ‚ö†Ô∏è Aucun item reforgeable trouv√©");
      return;
    }

    const testItem = reforgeableItems[0];
    console.log(`   üó°Ô∏è Item test: ${testItem.name} (${testItem.rarity})`);
    console.log(`   üìä Stats actuelles: ${Object.entries(testItem.currentStats).map(([stat, val]) => `${stat}:${val}`).join(', ')}`);

    // Test 2: Preview de reforge
    console.log(`\nüîÆ Test preview reforge:`);
    try {
      const preview = await reforgeService.getReforgePreview(testItem.instanceId);
      console.log(`   üí∞ Co√ªt: ${preview.cost.gold} or, ${preview.cost.gems} gemmes`);
      console.log(`   üé≤ Stats possibles:`);
      
      for (const [stat, range] of Object.entries(preview.possibleStats)) {
        const improvement = preview.improvementChances[stat] || 0;
        console.log(`      ${stat}: ${range.min}-${range.max} (${improvement}% am√©lioration)`);
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur preview: ${error.message}`);
    }

    // Test 3: Reforge simple
    console.log(`\nüîÑ Test reforge simple:`);
    try {
      const result = await reforgeService.executeReforge(testItem.instanceId);
      
      if (result.success) {
        console.log(`   ‚úÖ Reforge r√©ussi!`);
        console.log(`   üìà Changement de puissance: ${result.powerChange > 0 ? '+' : ''}${result.powerChange}`);
        console.log(`   üîÑ Nombre de reforges: ${result.reforgeCount}`);
        
        if (result.improvements.length > 0) {
          console.log(`   üìä Am√©liorations:`);
          result.improvements.forEach(imp => {
            const change = imp.improvement > 0 ? `+${imp.improvement}` : `${imp.improvement}`;
            console.log(`      ${imp.stat}: ${imp.oldValue} ‚Üí ${imp.newValue} (${change})`);
          });
        }
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur reforge: ${error.message}`);
    }

    // Test 4: Reforge avec stats lock√©es
    console.log(`\nüîí Test reforge avec stats lock√©es:`);
    try {
      const availableStats = reforgeService.getAvailableStatsForSlot(testItem.equipmentSlot);
      const lockedStats = availableStats.slice(0, 2); // Locker les 2 premi√®res stats
      
      const lockedResult = await reforgeService.executeReforge(testItem.instanceId, {
        lockedStats
      });
      
      if (lockedResult.success) {
        console.log(`   ‚úÖ Reforge avec ${lockedStats.length} stats lock√©es r√©ussi`);
        console.log(`   üîí Stats lock√©es: ${lockedStats.join(', ')}`);
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur reforge lock√©es: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test module reforge termin√©");
  }

  private async testFusionModule(): Promise<void> {
    colorLog(colors.cyan, "\nüîó === TEST MODULE FUSION ===");
    
    const fusionService = new FusionService(this.testPlayerId);
    
    // Test 1: R√©cup√©rer groupes fusionnables
    console.log("\nüìù Test r√©cup√©ration groupes fusionnables:");
    const fusableGroups = await fusionService.getFusableGroups();
    console.log(`   üéØ ${fusableGroups.length} groupes fusionnables trouv√©s`);
    
    for (const group of fusableGroups.slice(0, 3)) {
      console.log(`   üì¶ ${group.itemName} (${group.rarity}): ${group.availableCount} items, ${group.possibleFusions} fusions possibles`);
      console.log(`      ‚Üí ${group.targetRarity}, gain estim√©: ${group.estimatedPowerGain}`);
    }

    if (fusableGroups.length === 0) {
      console.log("   ‚ö†Ô∏è Aucun groupe fusionnable, test sur items individuels...");
      return;
    }

    // Test 2: Preview de fusion
    const testGroup = fusableGroups[0];
    console.log(`\nüîÆ Test preview fusion pour: ${testGroup.itemName}`);
    
    // Trouver 3 items identiques
    const inventory = await this.getPlayerInventory();
    const identicalItems = this.findIdenticalItems(inventory, testGroup.itemId, 3);
    
    if (identicalItems.length >= 3) {
      try {
        const preview = await fusionService.getFusionPreview(identicalItems.slice(0, 3));
        
        if (preview.canFuse) {
          console.log(`   ‚úÖ Fusion possible: ${preview.expectedResult.rarity}`);
          console.log(`   üí∞ Co√ªt: ${preview.cost.gold} or, ${preview.cost.gems} gemmes`);
          console.log(`   üìà Gain estim√©: ${preview.expectedResult.estimatedPowerGain}`);
          console.log(`   üìä Niveau conserv√©: ${preview.expectedResult.conservedLevel}`);
          console.log(`   ‚ö° Enhancement conserv√©: ${preview.expectedResult.conservedEnhancement}`);
        } else {
          console.log(`   ‚ùå Fusion impossible: ${preview.reason}`);
        }
      } catch (error: any) {
        console.log(`   ‚ùå Erreur preview: ${error.message}`);
      }

      // Test 3: Ex√©cution de fusion
      console.log(`\nüîó Test ex√©cution fusion:`);
      try {
        const fusionResult = await fusionService.executeFusion(identicalItems.slice(0, 3));
        
        if (fusionResult.success && fusionResult.newItem) {
          console.log(`   ‚úÖ Fusion r√©ussie!`);
          console.log(`   üéâ Nouvel item: ${fusionResult.newItem.name} (${fusionResult.newItem.rarity})`);
          console.log(`   üìà Puissance: ${fusionResult.statsComparison.newPowerScore} (+${fusionResult.statsComparison.powerIncrease})`);
          console.log(`   üîÑ ${fusionResult.consumedItems.length} items consomm√©s`);
        }
      } catch (error: any) {
        console.log(`   ‚ùå Erreur fusion: ${error.message}`);
      }
    } else {
      console.log(`   ‚ö†Ô∏è Pas assez d'items identiques (${identicalItems.length}/3)`);
    }

    colorLog(colors.green, "‚úÖ Test module fusion termin√©");
  }

  private async testTierUpgradeModule(): Promise<void> {
    colorLog(colors.cyan, "\n‚¨ÜÔ∏è === TEST MODULE TIER UPGRADE ===");
    
    const tierUpgradeService = new TierUpgradeService(this.testPlayerId);
    
    // Test 1: R√©cup√©rer items upgradables
    console.log("\nüìù Test r√©cup√©ration items upgradables:");
    const upgradableItems = await tierUpgradeService.getUpgradableItems();
    console.log(`   üéØ ${upgradableItems.length} items upgradables trouv√©s`);
    
    for (const item of upgradableItems.slice(0, 3)) {
      console.log(`   üì¶ ${item.name} (${item.rarity}): T${item.currentTier}/${item.maxPossibleTier}`);
      if (item.upgradeCost) {
        console.log(`      üí∞ Co√ªt: ${item.upgradeCost.gold} or, gain estim√©: ${item.powerGainEstimate}`);
      }
    }

    if (upgradableItems.length === 0) {
      console.log("   ‚ö†Ô∏è Aucun item upgradable trouv√©");
      return;
    }

    const testItem = upgradableItems[0];
    
    // Test 2: Preview tier upgrade
    console.log(`\nüîÆ Test preview tier upgrade pour: ${testItem.name}`);
    try {
      const preview = await tierUpgradeService.getTierUpgradePreview(testItem.instanceId);
      
      if (preview.canUpgrade) {
        console.log(`   ‚úÖ Upgrade possible: T${preview.currentTier} ‚Üí T${preview.targetTier}`);
        console.log(`   üí∞ Co√ªt: ${preview.cost.gold} or, ${preview.cost.gems} gemmes`);
        console.log(`   üìà Am√©lioration: ${preview.multipliers.improvement}`);
        
        if (preview.totalCostToMax) {
          console.log(`   üéØ Co√ªt total au max: ${preview.totalCostToMax.gold} or (${preview.totalCostToMax.steps} √©tapes)`);
        }
      } else {
        console.log(`   ‚ùå Upgrade impossible: ${preview.reason}`);
      }
    } catch (error: any) {
      console.log(`   ‚ùå Erreur preview: ${error.message}`);
    }

    // Test 3: Ex√©cution tier upgrade
    if (testItem.canUpgrade) {
      console.log(`\n‚¨ÜÔ∏è Test ex√©cution tier upgrade:`);
      try {
        const upgradeResult = await tierUpgradeService.executeTierUpgrade(testItem.instanceId);
        
        if (upgradeResult.success) {
          console.log(`   ‚úÖ Upgrade r√©ussi: T${upgradeResult.previousTier} ‚Üí T${upgradeResult.newTier}`);
          console.log(`   üìà Gain de puissance: ${upgradeResult.statsImprovement.powerIncrease} (+${upgradeResult.statsImprovement.percentageIncrease.toFixed(1)}%)`);
          console.log(`   üéØ Multiplicateur tier: x${upgradeResult.tierMultiplier}`);
          
          if (upgradeResult.maxTierReached) {
            console.log(`   üèÜ Tier maximum atteint!`);
          }
          
          if (upgradeResult.unlockedFeatures.length > 0) {
            console.log(`   üéâ Features d√©bloqu√©es: ${upgradeResult.unlockedFeatures.join(', ')}`);
          }
        }
      } catch (error: any) {
        console.log(`   ‚ùå Erreur upgrade: ${error.message}`);
      }
    }

    // Test 4: Calcul co√ªt total au max
    console.log(`\nüéØ Test calcul co√ªt total au maximum:`);
    try {
      const totalCost = await tierUpgradeService.getTotalUpgradeCostToMax(testItem.instanceId);
      console.log(`   üí∞ Co√ªt total: ${totalCost.totalGold} or, ${totalCost.totalGems} gemmes`);
      console.log(`   üìà ${totalCost.steps.length} √©tapes d'upgrade n√©cessaires`);
      
      if (Object.keys(totalCost.totalMaterials).length > 0) {
        console.log(`   üì¶ Mat√©riaux: ${Object.entries(totalCost.totalMaterials).map(([id, qty]) => `${id}:${qty}`).join(', ')}`);
      }
    } catch (error: any) {
      console.log(`   ‚ö†Ô∏è Calcul co√ªt total: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test module tier upgrade termin√©");
  }

  private async testForgeServiceIntegration(): Promise<void> {
    colorLog(colors.cyan, "\nüéõÔ∏è === TEST INT√âGRATION FORGE SERVICE ===");
    
    const forgeService = new ForgeService(this.testPlayerId);
    
    // Test 1: Statut forge global
    console.log("\nüìä Test statut forge:");
    try {
      const status = await forgeService.getForgeStatus();
      
      console.log(`   üë§ Joueur: ${status.playerId}`);
      console.log(`   üí∞ Ressources: ${status.playerResources.gold} or, ${status.playerResources.gems} gemmes`);
      console.log(`   üíé Gemmes pay√©es: ${status.playerResources.paidGems}`);
      
      console.log(`   üîß Modules:`);
      Object.entries(status.modules).forEach(([name, module]) => {
        const statusIcon = module.enabled ? '‚úÖ' : '‚ùå';
        console.log(`      ${statusIcon} ${name}: ${module.availableOperations} op√©rations disponibles`);
      });
      
      console.log(`   üì¶ Inventaire:`);
      console.log(`      üîÑ Reforge: ${status.inventory.reforgeableItems} items`);
      console.log(`      ‚ö° Enhancement: ${status.inventory.enhanceableItems} items`);
      console.log(`      üîó Fusion: ${status.inventory.fusableItems} groupes`);
      console.log(`      ‚¨ÜÔ∏è Tier: ${status.inventory.upgradeableItems} items`);
      
      console.log(`   üìà Stats globales:`);
      console.log(`      üéØ Op√©rations totales: ${status.globalStats.totalOperations}`);
      console.log(`      üí∞ Or d√©pens√©: ${status.globalStats.totalGoldSpent}`);
      console.log(`      üèÜ Module favori: ${status.globalStats.favoriteModule}`);
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur statut forge: ${error.message}`);
    }

    // Test 2: Analytics d'usage
    console.log(`\nüìä Test analytics d'usage:`);
    try {
      const analytics = await forgeService.getUsageAnalytics();
      
      console.log(`   üéØ Module favori: ${analytics.favoriteModule}`);
      console.log(`   üìÖ Op√©rations cette semaine: ${analytics.operationsThisWeek}`);
      console.log(`   üìà Moyenne quotidienne: ${analytics.avgDailyOperations}`);
      console.log(`   üí∞ Investissement total: ${analytics.totalInvestment.gold} or, ${analytics.totalInvestment.gems} gemmes`);
      console.log(`   üìä ROI: ${analytics.roi}%`);
      console.log(`   ‚ö° Efficacit√©: ${analytics.efficiency} power/or`);
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur analytics: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test int√©gration ForgeService termin√©");
  }

  private async testBatchOperations(): Promise<void> {
    colorLog(colors.cyan, "\nüì¶ === TEST OP√âRATIONS EN LOT ===");
    
    const forgeService = new ForgeService(this.testPlayerId);
    
    // Pr√©parer des op√©rations de test
    const operations = [];
    
    // Quelques enhancements
    const enhanceableItems = await forgeService.getEnhanceableItems();
    for (const item of enhanceableItems.slice(0, 2)) {
      operations.push({
        type: 'enhancement' as const,
        itemInstanceId: item.instanceId,
        parameters: {}
      });
    }
    
    // Quelques reforges
    const reforgeableItems = await forgeService.getReforgeableItems();
    for (const item of reforgeableItems.slice(0, 2)) {
      operations.push({
        type: 'reforge' as const,
        itemInstanceId: item.instanceId,
        parameters: { lockedStats: [] }
      });
    }

    console.log(`\nüéØ Pr√©paration de ${operations.length} op√©rations en lot:`);
    operations.forEach((op, i) => {
      console.log(`   ${i + 1}. ${op.type} sur ${op.itemInstanceId.substring(0, 8)}...`);
    });

    if (operations.length === 0) {
      console.log("   ‚ö†Ô∏è Aucune op√©ration disponible pour le test batch");
      return;
    }

    // Test d'ex√©cution en lot
    console.log(`\nüì¶ Test ex√©cution batch:`);
    try {
      const startTime = Date.now();
      const batchResult = await forgeService.executeBatchOperations(operations);
      const executionTime = Date.now() - startTime;
      
      console.log(`   ‚úÖ Batch termin√© en ${executionTime}ms`);
      console.log(`   üéØ Op√©rations r√©ussies: ${batchResult.completedOperations}/${batchResult.totalOperations}`);
      console.log(`   üí∞ Co√ªt total: ${batchResult.totalCost.gold} or, ${batchResult.totalCost.gems} gemmes`);
      console.log(`   üìà Gain de puissance total: ${batchResult.totalPowerGain}`);
      
      // D√©tail des r√©sultats
      const successCount = batchResult.results.filter(r => r.success).length;
      const failCount = batchResult.results.filter(r => !r.success).length;
      console.log(`   üìä D√©tail: ${successCount} succ√®s, ${failCount} √©checs`);
      
      if (failCount > 0) {
        console.log(`   ‚ùå Erreurs rencontr√©es:`);
        batchResult.results.filter(r => !r.success).forEach((result, i) => {
          console.log(`      ${i + 1}. ${result.operation.type}: ${result.error}`);
        });
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur batch: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test op√©rations batch termin√©");
  }

  private async testRecommendations(): Promise<void> {
    colorLog(colors.cyan, "\nüéØ === TEST SYST√àME DE RECOMMANDATIONS ===");
    
    const forgeService = new ForgeService(this.testPlayerId);
    
    console.log(`\nü§ñ Test g√©n√©ration de recommandations:`);
    try {
      const recommendations = await forgeService.getRecommendations();
      
      console.log(`   üéØ ${recommendations.length} recommandations g√©n√©r√©es:`);
      
      recommendations.forEach((rec, i) => {
        const priorityIcon = rec.priority === 'high' ? 'üî•' : rec.priority === 'medium' ? '‚ö°' : 'üí°';
        console.log(`\n   ${i + 1}. ${priorityIcon} ${rec.type.toUpperCase()} - ${rec.itemName}`);
        console.log(`      üìù Raison: ${rec.reasoning}`);
        console.log(`      üéÅ B√©n√©fice: ${rec.expectedBenefit}`);
        console.log(`      üí∞ Co√ªt: ${rec.cost.gold || 0} or`);
        console.log(`      üìà Gain estim√©: ${rec.powerGainEstimate}`);
        console.log(`      ‚ö° Score efficacit√©: ${rec.efficiencyScore}`);
      });
      
      if (recommendations.length === 0) {
        console.log(`   üí≠ Aucune recommandation disponible - √©quipement optimis√© ou ressources insuffisantes`);
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur recommandations: ${error.message}`);
    }

    // Test optimisation compl√®te
    console.log(`\nüéØ Test calcul optimisation compl√®te:`);
    try {
      const optimizationCost = await forgeService.getFullOptimizationCost();
      
      console.log(`   üí∞ Co√ªt total optimisation:`);
      console.log(`      Or: ${optimizationCost.totalCost.gold}`);
      console.log(`      Gemmes: ${optimizationCost.totalCost.gems}`);
      
      if (Object.keys(optimizationCost.totalCost.materials).length > 0) {
        console.log(`      Mat√©riaux: ${Object.entries(optimizationCost.totalCost.materials).map(([id, qty]) => `${id}:${qty}`).join(', ')}`);
      }
      
      console.log(`   üîß Op√©rations pr√©vues:`);
      console.log(`      ‚ö° Enhancements: ${optimizationCost.operations.enhancements}`);
      console.log(`      üîÑ Reforges: ${optimizationCost.operations.reforges}`);
      console.log(`      üîó Fusions: ${optimizationCost.operations.fusions}`);
      console.log(`      ‚¨ÜÔ∏è Tier upgrades: ${optimizationCost.operations.tierUpgrades}`);
      
      console.log(`   üìà Gain de puissance estim√©: ${optimizationCost.estimatedPowerGain}`);
      console.log(`   ‚è±Ô∏è Temps estim√©: ${optimizationCost.estimatedTime}`);
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur calcul optimisation: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test recommandations termin√©");
  }

  private async testAnalytics(): Promise<void> {
    colorLog(colors.cyan, "\nüìä === TEST ANALYTICS ET STATISTIQUES ===");
    
    // Test stats des op√©rations
    console.log(`\nüìà Test statistiques des op√©rations:`);
    try {
      const operations = await ForgeOperation.find({ playerId: this.testPlayerId }).limit(10);
      console.log(`   üéØ ${operations.length} op√©rations trouv√©es pour ce joueur`);
      
      if (operations.length > 0) {
        const successCount = operations.filter(op => op.result.success).length;
        const successRate = (successCount / operations.length * 100).toFixed(1);
        console.log(`   üìä Taux de succ√®s: ${successRate}%`);
        
        // Grouper par type
        const byType = operations.reduce((acc, op) => {
          acc[op.operationType] = (acc[op.operationType] || 0) + 1;
          return acc;
        }, {} as { [key: string]: number });
        
        console.log(`   üîß Par type:`);
        Object.entries(byType).forEach(([type, count]) => {
          console.log(`      ${type}: ${count} op√©rations`);
        });
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur stats op√©rations: ${error.message}`);
    }

    // Test stats du joueur
    console.log(`\nüë§ Test statistiques joueur:`);
    try {
      const playerStats = await ForgeStats.findOne({ playerId: this.testPlayerId });
      
      if (playerStats) {
        console.log(`   üéØ Op√©rations totales: ${playerStats.globalStats.totalOperations}`);
        console.log(`   üí∞ Or d√©pens√©: ${playerStats.globalStats.totalGoldSpent}`);
        console.log(`   üíé Gemmes d√©pens√©es: ${playerStats.globalStats.totalGemsSpent}`);
        console.log(`   üìà Puissance gagn√©e: ${playerStats.globalStats.totalPowerGained}`);
        console.log(`   üèÜ Module favori: ${playerStats.globalStats.favoriteModule}`);
        console.log(`   ‚ö° Score efficacit√©: ${playerStats.cachedData.efficiencyScore}`);
        
        // Streaks
        console.log(`   üî• Streak succ√®s actuel: ${playerStats.streaks.currentSuccessStreak}`);
        console.log(`   üèÜ Meilleur streak: ${playerStats.streaks.bestSuccessStreak}`);
        
        // Records
        console.log(`   üìä Records:`);
        console.log(`      üí∞ Op√©ration la plus ch√®re: ${playerStats.achievements.records.mostExpensiveOperation} or`);
        console.log(`      üìà Plus grand gain de puissance: ${playerStats.achievements.records.highestSinglePowerGain}`);
        console.log(`      ‚ö° Op√©ration la plus rapide: ${playerStats.achievements.records.fastestOperation}ms`);
      } else {
        console.log(`   üí≠ Aucune statistique trouv√©e pour ce joueur`);
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur stats joueur: ${error.message}`);
    }

    // Test achievements
    console.log(`\nüèÜ Test syst√®me d'achievements:`);
    try {
      const playerStats = await ForgeStats.findOne({ playerId: this.testPlayerId });
      
      if (playerStats) {
        const newAchievements = playerStats.checkAchievements();
        
        if (newAchievements.length > 0) {
          console.log(`   üéâ ${newAchievements.length} nouveaux achievements d√©bloqu√©s:`);
          newAchievements.forEach(achievement => {
            console.log(`      üèÜ ${achievement}`);
          });
        } else {
          console.log(`   üí≠ Aucun nouvel achievement d√©bloqu√©`);
        }
        
        console.log(`   üéØ Achievements actuels: ${playerStats.achievements.unlockedAchievements.length}`);
        
        // Milestones
        const milestones = playerStats.achievements.milestones;
        console.log(`   üìä Milestones atteints:`);
        console.log(`      üéØ Op√©rations: ${milestones.totalOperations.length}`);
        console.log(`      üí∞ Or d√©pens√©: ${milestones.goldSpent.length}`);
        console.log(`      üìà Puissance: ${milestones.powerGained.length}`);
        console.log(`      üî• Streaks: ${milestones.streaks.length}`);
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur achievements: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test analytics termin√©");
  }

  private async testPerformance(): Promise<void> {
    colorLog(colors.cyan, "\n‚ö° === TEST PERFORMANCE ===");
    
    // Test performance r√©cup√©ration donn√©es
    console.log(`\nüèÉ Test vitesse r√©cup√©ration donn√©es:`);
    const startTime = Date.now();
    
    try {
      const forgeService = new ForgeService(this.testPlayerId);
      
      const [
        status,
        enhanceableItems,
        reforgeableItems,
        fusableGroups,
        upgradableItems,
        recommendations
      ] = await Promise.all([
        forgeService.getForgeStatus(),
        forgeService.getEnhanceableItems(),
        forgeService.getReforgeableItems(),
        forgeService.getFusableGroups(),
        forgeService.getUpgradableItems(),
        forgeService.getRecommendations()
      ]);
      
      const totalTime = Date.now() - startTime;
      
      console.log(`   ‚ö° Temps total: ${totalTime}ms`);
      console.log(`   üìä Donn√©es r√©cup√©r√©es simultan√©ment:`);
      console.log(`      üéõÔ∏è Statut forge: ‚úÖ`);
      console.log(`      ‚ö° ${enhanceableItems.length} items enhanceables`);
      console.log(`      üîÑ ${reforgeableItems.length} items reforgeables`);
      console.log(`      üîó ${fusableGroups.length} groupes fusionnables`);
      console.log(`      ‚¨ÜÔ∏è ${upgradableItems.length} items upgradables`);
      console.log(`      üéØ ${recommendations.length} recommandations`);
      
      if (totalTime < 500) {
        colorLog(colors.green, "   ‚úÖ Performance excellente (< 500ms)");
      } else if (totalTime < 1500) {
        colorLog(colors.yellow, "   ‚ö†Ô∏è Performance acceptable (< 1.5s)");
      } else {
        colorLog(colors.red, "   ‚ùå Performance lente (> 1.5s)");
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur test performance: ${error.message}`);
    }

    // Test performance op√©rations multiples
    console.log(`\nüîÑ Test performance op√©rations multiples:`);
    try {
      const operations = [];
      const enhanceableItems = await (new ForgeService(this.testPlayerId)).getEnhanceableItems();
      
      // Pr√©parer 5 op√©rations de test
      for (let i = 0; i < Math.min(5, enhanceableItems.length); i++) {
        operations.push({
          type: 'enhancement' as const,
          itemInstanceId: enhanceableItems[i].instanceId,
          parameters: { simulationMode: true } // Mode simulation pour √©viter les modifications
        });
      }
      
      if (operations.length > 0) {
        const operationStartTime = Date.now();
        
        // S√©quentiel
        console.log(`   üîÑ Test s√©quentiel (${operations.length} op√©rations):`);
        for (let i = 0; i < operations.length; i++) {
          const singleStart = Date.now();
          try {
            const enhancementService = new EnhancementService(this.testPlayerId);
            await enhancementService.attemptEnhancement(operations[i].itemInstanceId, { 
              simulationMode: true 
            } as any);
            const singleTime = Date.now() - singleStart;
            console.log(`      ${i + 1}. ${singleTime}ms`);
          } catch (error) {
            console.log(`      ${i + 1}. Erreur (pas de modification)`);
          }
        }
        
        const sequentialTime = Date.now() - operationStartTime;
        console.log(`   ‚è±Ô∏è Total s√©quentiel: ${sequentialTime}ms`);
        console.log(`   üìä Moyenne par op√©ration: ${Math.round(sequentialTime / operations.length)}ms`);
      } else {
        console.log(`   ‚ö†Ô∏è Aucune op√©ration disponible pour le test performance`);
      }
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur test op√©rations multiples: ${error.message}`);
    }

    // Test performance base de donn√©es
    console.log(`\nüíæ Test performance base de donn√©es:`);
    try {
      const dbStartTime = Date.now();
      
      const [
        operationsCount,
        statsCount,
        configsCount
      ] = await Promise.all([
        ForgeOperation.countDocuments({}),
        ForgeStats.countDocuments({}),
        ForgeConfig.countDocuments({})
      ]);
      
      const dbTime = Date.now() - dbStartTime;
      
      console.log(`   üìä Comptages BD en ${dbTime}ms:`);
      console.log(`      üîß Op√©rations: ${operationsCount}`);
      console.log(`      üìà Stats: ${statsCount}`);
      console.log(`      ‚öôÔ∏è Configurations: ${configsCount}`);
      
    } catch (error: any) {
      console.log(`   ‚ùå Erreur test BD: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test performance termin√©");
  }

  // === M√âTHODES AVANC√âES ===

  private async testErrorHandling(): Promise<void> {
    colorLog(colors.cyan, "\nüö® === TEST GESTION D'ERREURS ===");
    
    const forgeService = new ForgeService(this.testPlayerId);
    
    // Test 1: Item inexistant
    console.log(`\nüëª Test item inexistant:`);
    try {
      await forgeService.executeEnhancement("fake_item_id");
      console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
    } catch (error: any) {
      console.log(`   ‚úÖ Erreur attendue: ${error.message}`);
    }

    // Test 2: Ressources insuffisantes
    console.log(`\nüí∏ Test ressources insuffisantes:`);
    try {
      const player = await Player.findById(this.testPlayerId);
      if (player) {
        const originalGold = player.gold;
        player.gold = 0;
        await player.save();
        
        const enhanceableItems = await forgeService.getEnhanceableItems();
        if (enhanceableItems.length > 0) {
          await forgeService.executeEnhancement(enhanceableItems[0].instanceId);
          console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
        }
        
        // Restaurer
        player.gold = originalGold;
        await player.save();
      }
    } catch (error: any) {
      console.log(`   ‚úÖ Erreur attendue: ${error.message}`);
    }

    // Test 3: Configuration d√©sactiv√©e
    console.log(`\n‚öôÔ∏è Test module d√©sactiv√©:`);
    try {
      const config = await ForgeConfig.findOne({ isActive: true });
      if (config) {
        config.config.enhancement.enabled = false;
        await config.save();
        
        const enhanceableItems = await forgeService.getEnhanceableItems();
        if (enhanceableItems.length > 0) {
          await forgeService.executeEnhancement(enhanceableItems[0].instanceId);
          console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
        }
        
        // Restaurer
        config.config.enhancement.enabled = true;
        await config.save();
      }
    } catch (error: any) {
      console.log(`   ‚úÖ Erreur attendue: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test gestion d'erreurs termin√©");
  }

  private async testEdgeCases(): Promise<void> {
    colorLog(colors.cyan, "\nüß© === TEST CAS LIMITES ===");
    
    // Test 1: Item au niveau maximum
    console.log(`\nüèÜ Test item niveau maximum:`);
    try {
      const inventory = await this.getPlayerInventory();
      const items = inventory.storage.weapons || [];
      
      if (items.length > 0) {
        const testItem = items[0];
        testItem.enhancement = 30; // Niveau max
        await inventory.save();
        
        const enhancementService = new EnhancementService(this.testPlayerId);
        await enhancementService.attemptEnhancement(testItem.instanceId);
        console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
      }
    } catch (error: any) {
      console.log(`   ‚úÖ Limitation respect√©e: ${error.message}`);
    }

    // Test 2: Fusion avec items diff√©rents
    console.log(`\nüîÄ Test fusion items incompatibles:`);
    try {
      const inventory = await this.getPlayerInventory();
      const weapons = inventory.storage.weapons || [];
      const armors = inventory.storage.armors || [];
      
      if (weapons.length > 0 && armors.length > 0) {
        const differentItems = [
          weapons[0].instanceId,
          armors[0].instanceId,
          weapons[1]?.instanceId || weapons[0].instanceId
        ];
        
        const fusionService = new FusionService(this.testPlayerId);
        await fusionService.executeFusion(differentItems);
        console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
      }
    } catch (error: any) {
      console.log(`   ‚úÖ Validation respect√©e: ${error.message}`);
    }

    // Test 3: Tier upgrade au maximum
    console.log(`\nüìè Test tier upgrade maximum:`);
    try {
      const inventory = await this.getPlayerInventory();
      const items = inventory.storage.weapons || [];
      
      if (items.length > 0) {
        const testItem = items[0];
        (testItem as any).tier = 5; // Tier max
        await inventory.save();
        
        const tierService = new TierUpgradeService(this.testPlayerId);
        await tierService.executeTierUpgrade(testItem.instanceId);
        console.log(`   ‚ùå ERREUR: Devrait √©chouer`);
      }
    } catch (error: any) {
      console.log(`   ‚úÖ Limitation respect√©e: ${error.message}`);
    }

    colorLog(colors.green, "‚úÖ Test cas limites termin√©");
  }

  // === AFFICHAGE ET STATISTIQUES FINALES ===

  public async displayFinalStats(): Promise<void> {
    colorLog(colors.cyan, "\nüìà === STATISTIQUES FINALES FORGE ===");
    
    // Stats du joueur de test
    const forgeService = new ForgeService(this.testPlayerId);
    const status = await forgeService.getForgeStatus();
    const analytics = await forgeService.getUsageAnalytics();
    
    console.log("\nüë§ Statistiques du joueur de test:");
    console.log(`   üí∞ Ressources: ${status.playerResources.gold} or, ${status.playerResources.gems} gemmes`);
    console.log(`   üéØ Op√©rations totales: ${status.globalStats.totalOperations}`);
    console.log(`   üí∏ Or d√©pens√©: ${status.globalStats.totalGoldSpent}`);
    console.log(`   üìà Puissance gagn√©e: ${status.globalStats.totalPowerGained}`);
    console.log(`   üèÜ Module favori: ${status.globalStats.favoriteModule}`);
    console.log(`   ‚ö° Efficacit√©: ${analytics.efficiency} power/or`);

    // Stats inventaire
    console.log("\nüì¶ Statistiques inventaire:");
    console.log(`   üîÑ Items reforgeables: ${status.inventory.reforgeableItems}`);
    console.log(`   ‚ö° Items enhanceables: ${status.inventory.enhanceableItems}`);
    console.log(`   üîó Groupes fusionnables: ${status.inventory.fusableItems}`);
    console.log(`   ‚¨ÜÔ∏è Items upgradables: ${status.inventory.upgradeableItems}`);

    // Stats syst√®me
    const [operationsCount, statsCount, configsCount] = await Promise.all([
      ForgeOperation.countDocuments({}),
      ForgeStats.countDocuments({}),
      ForgeConfig.countDocuments({})
    ]);
    
    console.log("\nüéÆ Statistiques syst√®me:");
    console.log(`   üîß Op√©rations totales: ${operationsCount}`);
    console.log(`   üë• Joueurs avec stats: ${statsCount}`);
    console.log(`   ‚öôÔ∏è Configurations: ${configsCount}`);

    // Validation finale
    console.log("\n‚úÖ Validation finale du syst√®me:");
    console.log("   üèóÔ∏è Architecture: Modulaire et extensible");
    console.log("   üîí S√©curit√©: Validation stricte des inputs");
    console.log("   ‚öñÔ∏è √âquilibrage: Syst√®me de co√ªts progressifs");
    console.log("   üìä Analytics: Tracking complet des op√©rations");
    console.log("   üéØ Recommandations: IA d'optimisation");
    console.log("   ‚ö° Performance: Op√©rations rapides");
    console.log("   üîß Configuration: Syst√®me flexible");

    colorLog(colors.green, "üéâ SYST√àME DE FORGE PR√äT POUR LA PRODUCTION ! üéâ");
  }

  // === M√âTHODES UTILITAIRES ===

  private async getPlayerInventory() {
    return await Inventory.findOne({ playerId: this.testPlayerId });
  }

  private findIdenticalItems(inventory: any, itemId: string, count: number): string[] {
    const instanceIds: string[] = [];
    
    const categories = ['weapons', 'armors', 'helmets', 'boots', 'gloves', 'accessories'];
    
    for (const category of categories) {
      const items = inventory.storage[category] || [];
      for (const item of items) {
        if (item.itemId === itemId && instanceIds.length < count) {
          instanceIds.push(item.instanceId);
        }
      }
      if (instanceIds.length >= count) break;
    }
    
    return instanceIds;
  }

  // === TESTS SP√âCIALIS√âS ===

  public async runBasicTests(): Promise<void> {
    await this.setupDatabase();
    await this.setupTestPlayer();
    await this.setupTestItems();
    await this.testForgeConfiguration();
    await this.testEnhancementModule();
    await this.testReforgeModule();
  }

  public async runAdvancedTests(): Promise<void> {
    await this.testFusionModule();
    await this.testTierUpgradeModule();
    await this.testForgeServiceIntegration();
    await this.testBatchOperations();
    await this.testRecommendations();
  }

  public async runPerformanceTests(): Promise<void> {
    await this.testPerformance();
    await this.testAnalytics();
  }

  public async runErrorTests(): Promise<void> {
    await this.testErrorHandling();
    await this.testEdgeCases();
  }

  public async runFullTestSuite(): Promise<void> {
    await this.runBasicTests();
    await this.runAdvancedTests();
    await this.runPerformanceTests();
    await this.runErrorTests();
  }
}

// === FONCTIONS UTILITAIRES ===

async function showTestMenu(): Promise<string> {
  const readline = require('readline');
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  console.log("\nüî® === MENU DES TESTS DE FORGE ===");
  console.log("1. Tests basiques (config, enhancement, reforge)");
  console.log("2. Tests avanc√©s (fusion, tier, int√©gration, batch)");
  console.log("3. Tests de performance (vitesse, analytics)");
  console.log("4. Tests d'erreurs (gestion erreurs, cas limites)");
  console.log("5. Suite compl√®te (tous les tests)");
  console.log("6. Statistiques uniquement");
  console.log("0. Quitter");

  return new Promise((resolve) => {
    rl.question("\nChoisissez une option (1-6, 0 pour quitter): ", (answer: string) => {
      rl.close();
      resolve(answer.trim());
    });
  });
}

async function displaySystemOverview(): Promise<void> {
  try {
    await mongoose.connect(MONGO_URI);
    
    colorLog(colors.cyan, "\nüìä === APER√áU DU SYST√àME FORGE ===");
    
    const [configCount, operationCount, statsCount] = await Promise.all([
      ForgeConfig.countDocuments({}),
      ForgeOperation.countDocuments({}),
      ForgeStats.countDocuments({})
    ]);
    
    console.log(`‚öôÔ∏è Configurations forge: ${configCount}`);
    console.log(`üîß Op√©rations enregistr√©es: ${operationCount}`);
    console.log(`üìà Joueurs avec stats: ${statsCount}`);
    
    if (configCount > 0) {
      const activeConfig = await ForgeConfig.findOne({ isActive: true });
      if (activeConfig) {
        console.log(`üéØ Configuration active: ${activeConfig.configName} v${activeConfig.version}`);
        
        const modules = ['reforge', 'enhancement', 'fusion', 'tierUpgrade'];
        const enabledModules = modules.filter(module => activeConfig.isModuleEnabled(module));
        console.log(`üîß Modules actifs: ${enabledModules.join(', ')}`);
        
        if (activeConfig.activeEvents.length > 0) {
          console.log(`üéâ √âv√©nements actifs: ${activeConfig.activeEvents.length}`);
        }
      } else {
        console.log(`‚ö†Ô∏è Aucune configuration active trouv√©e`);
      }
    }
    
    if (operationCount > 0) {
      const recentOperations = await ForgeOperation.find({})
        .sort({ timestamp: -1 })
        .limit(5);
      
      console.log(`üìä Derni√®res op√©rations:`);
      recentOperations.forEach((op, i) => {
        const status = op.result.success ? '‚úÖ' : '‚ùå';
        const timeAgo = Math.round((Date.now() - op.timestamp.getTime()) / (1000 * 60));
        console.log(`   ${i + 1}. ${status} ${op.operationType} (il y a ${timeAgo}min)`);
      });
    }
    
    await mongoose.disconnect();
    
  } catch (error) {
    console.error("Erreur aper√ßu syst√®me:", error);
  }
}

// === SCRIPT PRINCIPAL ===
async function main() {
  try {
    // Afficher l'aper√ßu du syst√®me
    await displaySystemOverview();
    
    // Menu interactif
    const choice = await showTestMenu();
    
    if (choice === "0") {
      console.log("üëã Au revoir !");
      return;
    }
    
    // Connexion pour les tests
    await mongoose.connect(MONGO_URI);
    colorLog(colors.green, "‚úÖ Connect√© √† MongoDB pour les tests");
    
    const tester = new ForgeTester();
    
    switch (choice) {
      case "1":
        colorLog(colors.cyan, "\nüîß Lancement des tests basiques...");
        await tester.runBasicTests();
        break;
        
      case "2":
        colorLog(colors.cyan, "\nüéØ Lancement des tests avanc√©s...");
        await tester.runAdvancedTests();
        break;
        
      case "3":
        colorLog(colors.cyan, "\n‚ö° Lancement des tests de performance...");
        await tester.runPerformanceTests();
        break;
        
      case "4":
        colorLog(colors.cyan, "\nüö® Lancement des tests d'erreurs...");
        await tester.runErrorTests();
        break;
        
      case "5":
        colorLog(colors.cyan, "\nüöÄ Lancement de la suite compl√®te...");
        await tester.runFullTestSuite();
        break;
        
      case "6":
        colorLog(colors.cyan, "\nüìä Affichage des statistiques...");
        await tester.setupDatabase();
        await tester.setupTestPlayer();
        await tester.displayFinalStats();
        break;
        
      default:
        colorLog(colors.red, "‚ùå Option invalide");
        return;
    }
    
  } catch (error) {
    colorLog(colors.red, `‚ùå Erreur lors des tests: ${error}`);
    console.error(error);
    process.exit(1);
  } finally {
    await mongoose.disconnect();
    colorLog(colors.green, "üîå D√©connect√© de MongoDB");
    process.exit(0);
  }
}

// Fonctions d'aide pour utilisation directe
export async function testForgeBasics() {
  await mongoose.connect(MONGO_URI);
  const tester = new ForgeTester();
  await tester.runBasicTests();
  await mongoose.disconnect();
}

export async function testForgeComplete() {
  await mongoose.connect(MONGO_URI);
  const tester = new ForgeTester();
  await tester.runFullTestSuite();
  await mongoose.disconnect();
}

export async function testForgeModule(module: 'enhancement' | 'reforge' | 'fusion' | 'tierUpgrade') {
  await mongoose.connect(MONGO_URI);
  const tester = new ForgeTester();
  await tester.setupDatabase();
  await tester.setupTestPlayer();
  await tester.setupTestItems();
  
  switch (module) {
    case 'enhancement':
      await tester.testEnhancementModule();
      break;
    case 'reforge':
      await tester.testReforgeModule();
      break;
    case 'fusion':
      await tester.testFusionModule();
      break;
    case 'tierUpgrade':
      await tester.testTierUpgradeModule();
      break;
  }
  
  await mongoose.disconnect();
}

// Aide et informations
function showHelp() {
  colorLog(colors.cyan, "\nüî® === SCRIPT DE TEST DU SYST√àME DE FORGE ===");
  console.log("\nCe script teste tous les aspects du syst√®me de forge:");
  console.log("‚Ä¢ ‚öôÔ∏è Configuration forge dynamique");
  console.log("‚Ä¢ ‚ö° Module Enhancement (am√©lioration +0 √† +30)");
  console.log("‚Ä¢ üîÑ Module Reforge (re-roll de stats avec locks)");
  console.log("‚Ä¢ üîó Module Fusion (3 items ‚Üí 1 item raret√© sup√©rieure)");
  console.log("‚Ä¢ ‚¨ÜÔ∏è Module Tier Upgrade (am√©lioration de tier T1 √† T5)");
  console.log("‚Ä¢ üì¶ Op√©rations en lot (batch operations)");
  console.log("‚Ä¢ üéØ Syst√®me de recommandations IA");
  console.log("‚Ä¢ üìä Analytics et statistiques compl√®tes");
  console.log("‚Ä¢ üèÜ Syst√®me d'achievements et milestones");
  console.log("‚Ä¢ ‚ö° Tests de performance");
  
  console.log("\nüìã Pr√©requis:");
  console.log("‚Ä¢ MongoDB en cours d'ex√©cution");
  console.log("‚Ä¢ Items cr√©√©s avec: npx ts-node src/scripts/seedItems.ts");
  console.log("‚Ä¢ Variables d'environnement configur√©es");
  
  console.log("\nüöÄ Lancement:");
  console.log("npx ts-node src/scripts/testForge.ts");
  
  console.log("\nüîß Usage programmatique:");
  console.log("import { testForgeBasics, testForgeComplete, testForgeModule } from './testForge';");
  console.log("await testForgeBasics(); // Tests de base");
  console.log("await testForgeComplete(); // Suite compl√®te");
  console.log("await testForgeModule('enhancement'); // Module sp√©cifique");
  
  console.log("\nüìä Modules test√©s:");
  console.log("‚úÖ Enhancement - Am√©lioration d'√©quipement (+0 √† +30)");
  console.log("  ‚Ä¢ Syst√®me de pity pour garantir les succ√®s");
  console.log("  ‚Ä¢ Co√ªts progressifs par raret√© et niveau");
  console.log("  ‚Ä¢ Support paid gems pour garanties");
  
  console.log("‚úÖ Reforge - Re-roll des stats d'√©quipement");
  console.log("  ‚Ä¢ Stats verrouillables (max 3)");
  console.log("  ‚Ä¢ Co√ªts selon raret√© et nombre de locks");
  console.log("  ‚Ä¢ Syst√®me de ranges par slot d'√©quipement");
  
  console.log("‚úÖ Fusion - Combiner 3 items identiques");
  console.log("  ‚Ä¢ Passage de raret√© (Common ‚Üí Mythic)");
  console.log("  ‚Ä¢ Conservation du meilleur niveau/enhancement");
  console.log("  ‚Ä¢ Validation stricte de compatibilit√©");
  
  console.log("‚úÖ Tier Upgrade - Am√©lioration de tier (T1 √† T5)");
  console.log("  ‚Ä¢ Multiplicateurs de stats par tier");
  console.log("  ‚Ä¢ Limites par raret√© d'item");
  console.log("  ‚Ä¢ Co√ªts exponentiels et mat√©riaux sp√©cialis√©s");
  
  console.log("‚úÖ Forge Service - Orchestration globale");
  console.log("  ‚Ä¢ Statut forge complet");
  console.log("  ‚Ä¢ Recommandations IA d'optimisation");
  console.log("  ‚Ä¢ Analytics et m√©triques de performance");
  console.log("  ‚Ä¢ Op√©rations batch pour efficacit√©");
  
  console.log("‚úÖ Syst√®me de configuration");
  console.log("  ‚Ä¢ Configuration hot-swappable");
  console.log("  ‚Ä¢ Support d'√©v√©nements temporaires");
  console.log("  ‚Ä¢ Ajustement des co√ªts et taux en temps r√©el");
  
  console.log("‚úÖ Analytics et Stats");
  console.log("  ‚Ä¢ Tracking complet de toutes les op√©rations");
  console.log("  ‚Ä¢ Statistiques par joueur et globales");
  console.log("  ‚Ä¢ Syst√®me d'achievements progressifs");
  console.log("  ‚Ä¢ M√©triques de performance et ROI");
  
  console.log("\nüéØ Fonctionnalit√©s test√©es:");
  console.log("‚úÖ Validation stricte des inputs et ressources");
  console.log("‚úÖ Gestion d'erreurs robuste");
  console.log("‚úÖ Performance optimis√©e (< 500ms par op√©ration)");
  console.log("‚úÖ Consistency de base de donn√©es");
  console.log("‚úÖ √âquilibrage √©conomique AFK Arena style");
  console.log("‚úÖ Extensibilit√© et maintenabilit√©");
  console.log("‚úÖ Logging complet pour monitoring");
  console.log("‚úÖ Tests de cas limites et edge cases");
  
  console.log("");
}

// Ex√©cuter le script si appel√© directement
if (require.main === module) {
  // Afficher l'aide si argument --help
  if (process.argv.includes("--help") || process.argv.includes("-h")) {
    showHelp();
    process.exit(0);
  }
  
  // Lancer le menu interactif
  main();
}

export { ForgeTester };
